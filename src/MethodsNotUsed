                                                        Hexagon

//    private eddieDir[] edgeDirections = new eddieDir[6]; //we have this. we do not have this

//constructor if we want to create hexagons out of the grid
//    public Hexagon(Edge n, Edge nw, Edge sw, Edge s, Edge se, Edge ne){
//        edge_n = n;
//        edge_nw = nw;
//        edge_sw = sw;
//        edge_s = s;
//        edge_se = se;
//        edge_ne = ne;
//        center = new Vertex(0,0);
//    }

//    /**
//     * 2 Hexagons are equal if the directions of their respective edges correspond to each other
//     * @param o
//     * @return
//     */
//    @Override
//    public boolean equals(Object o) {
//        if (this == o)
//            return true;
//        if (!(o instanceof Hexagon hexagon))
//            return false;
//        return edge_n.equals(hexagon.edge_n) && edge_nw.equals(hexagon.edge_nw) && edge_sw.equals(hexagon.edge_sw) && edge_s.equals(hexagon.edge_s) && edge_se.equals(hexagon.edge_se) && edge_ne.equals(hexagon.edge_ne);
//    }

    /**
     * Updates the hexagon according to the output of the rule, and the edges that should be changed. If a rule was not found, then push all eddies forward (only inside the hexagon)
     * @param output the output of the rule to be enforced
     * @param shouldBeChanged is true if a specific rule was found, false if not.
     */
    public void updateHexagonEddies(eddieDir[] output, boolean[] shouldBeChanged){ //Change to boolean later, or sth else
        Edge[] edges = getEdges();
        Vertex other;
        int[] changes = new int[6]; //need to be pushed forward. //could be boolean array
        boolean makeChanges = false;

        if(shouldBeChanged[0]) {
            for (int i = 0; i < 6; i++) {
                other = edges[i].getStart();

                //the output can include only FC or NA
                if ((output[i] == eddieDir.FC)) { //if the output is From-Center
                    if (center.equals(other))  //if edge start Vertex corresponds to center of hexagon
                        edges[i].setDirection(Edge.eddie.SE); //then set direction to Start-End
                    else
                        edges[i].setDirection(Edge.eddie.ES);
                } else {
                    edges[i].setDirection(Edge.eddie.NA);
                }

                if(!shouldBeChanged[i]) { //check if it is an eddie that should not be changed aka should be pushed forward, keep a list and push them forward after updating all edges
                    changes[i + 3 % 6] = 1;
                    makeChanges = true;
                }
            }
        }else{
            for (int i = 0; i < 6; i++) { //push forward (inside hexagon)
                if(edgeDirections[i] == eddieDir.TC) { //check if there is an eddie TC that should be pushed forward. We ignore FC eddies here. NA eddies do not change
                    changes[i + 3 % 6] = 1; //this means that the opposite direction of i should get an arrow FC
                    makeChanges = true;
                }
            }
        }
        //could join this with above. This was for rotation case.
        if(makeChanges) { //changed for not allowing rotations
            for (int i = 0; i < 6; i++) { //push forward. maybe I want to have this as a separate method, although this push happens inside the hexagon
                if (changes[i] == 1) { //this means that there should be an arrow in this direction. (going out)
                    if (center.equals(edges[i].getStart()))  //if edge start Vertex corresponds to center of hexagon
                        edges[i].setDirection(Edge.eddie.SE); //then set direction to Start-End
                    else
                        edges[i].setDirection(Edge.eddie.ES);
                }
            }
        }
    }

/**
     * Used in the constructor to set the initial edgeDirections()
     */
//    private void setInitialEdgeDirections(Edge n, Edge nw, Edge sw, Edge s, Edge se, Edge ne) {
//        Edge[] edges = {n,nw,sw,s,se,ne};
//
//        Vertex other;
//        for (int i = 0; i < 6; i++) {
//            if (edges[i].getDirection() != Edge.eddie.NA) { //if eddie has dir
//                other = edges[i].getStart();
//
//                if (center.equals(other)) { //if edge start Vertex corresponds to center of hexagon
//                    if (edges[i].getDirection() == Edge.eddie.SE) { //if eddie is Start-End
////                        edgeDirections[i] = eddieDir.FC;//then eddie direction is From-Center
//                        setDirection(i,eddieDir.FC);
//                    } else {
////                        edgeDirections[i] = eddieDir.TC;//otherwise direction is To-Center
//                        setDirection(i, eddieDir.TC);
//                    }
//                } else {
//                    if (edges[i].getDirection() == Edge.eddie.SE) {
////                        edgeDirections[i] = eddieDir.TC;
//                        setDirection(i,eddieDir.TC);
//                    } else {
////                        edgeDirections[i] = eddieDir.FC;
//                        setDirection(i, eddieDir.FC);
//                    }
//                }
//            } else{
//                setDirection(i, eddieDir.FC);
////                edgeDirections[i] = eddieDir.NA;
//            }
//
//        }
//    }

//            setDirection_n(output[0]);
//            setDirection_nw(output[1]);
//            setDirection_sw(output[2]);
//            setDirection_s(output[3]);
//            setDirection_se(output[4]);
//            setDirection_ne(output[5]);

//    public eddieDir[] getEdgeDirections() {
//        return new eddieDir[]{};
//    }

push forward logic

//    if(edgeDirections[i] == eddieDir.FC) //when pushing forward the eddie, we should decide what happens to it after
//        pushForward(i, false); // aka: setDirection((i + 3) % 6, eddieDir.FC);
//    else
//        pushForward(i, true);


private void pushForward(int i, boolean replace){
//        (i+3)%6 means that the opposite direction of i should get an arrow FC
        setDirection((i + 3) % 6, eddieDir.FC);

        if(replace)
            setDirection(i, eddieDir.NA);
    }


//    public Hexagon(Vertex center, VertexGrid vgrid, eddieDir[] directions){
//        new Hexagon(center,vgrid);
//
//        if(directions != null)
//
//    }

                                                        HexagonGrid

//                x = new int[]{i, i - 1, i - 1, i, i + 1, i + 1, i}; //n, nw, sw, s, se, ne
//                y = new int[]{j, j + 1, j + 2, j + 2, j + 2, j + 1, j + 1}; //j=0;i=1

//not a good clone
//    public HexagonGrid(HexagonGrid original){
//        if(original == null){
//            System.out.println("ERROR");
//            System.exit(0);
//        }
//        x_length = original.x_length;
//        y_width = original.y_width;
//
//        grid = new Hexagon[x_length][y_width];
//        for(int y=0;y<y_width;y++){
//            for(int x=0;x<x_length;x++){
//                grid[x][y] = new Hexagon(original.getHexagon(x,y));
//            }
//        }
//    }

//Used this one
public HexagonGrid(HexagonGrid original) {
        if (original == null) {
            System.out.println("ERROR");
            System.exit(0);
        }
        vGrid = new VertexGrid(original.x_length + 2, original.y_width + 2);

        x_length = original.x_length;
        y_width = original.y_width;

        grid = new Hexagon[x_length][y_width];
        for (int y = 0; y < y_width; y++) {
            for (int x = 0; x < x_length; x++) {
//                grid[x][y] = new Hexagon(original.getHexagon(x, y));
                grid[x][y] = new Hexagon(vGrid.getVertex(x,y), vGrid);
            }
        }
    }




                                                        Vertex
//    private Vertex right;
//    private Vertex left;
//    private Vertex up;
//    private Vertex down;

//    public void setUp(Vertex up) {
//        this.up = up;
//    }
//    public void setDown(Vertex down) {
//        this.down = down;
//    }
//    public void setLeft(Vertex left) {
//        this.left = left;
//    }
//    public void setRight(Vertex right) {
//        this.right = right;
//    }
//
//    public Vertex getUp() {
//        return up;
//    }
//    public Vertex getLeft() {
//        return left;
//    }
//    public Vertex getDown() {
//        return down;
//    }
//    public Vertex getRight() {
//        return right;
//    }





                                                            Wolfram Rules

//    public WolframRules(){
//        CircularlyLinkedList<Hexagon.eddieDir> q = new CircularlyLinkedList<>();
//        q.addFirst(Hexagon.eddieDir.NA);
//        q.addLast(Hexagon.eddieDir.TC);
//        q.addLast(Hexagon.eddieDir.NA);
//        q.addLast(Hexagon.eddieDir.NA);
//        q.addLast(Hexagon.eddieDir.TC);
//        q.addLast(Hexagon.eddieDir.NA);
//        b[0] = q;
//    }


//    Edge noEddie = new Edge(Edge.eddie.NA);
//    Edge fromCenter = new Edge(Edge.eddie.SE);
//    Edge toCenter = new Edge(Edge.eddie.ES);
//
//    //assume direction SE means: start = center
//    public final Hexagon[][] rule_378 = new Hexagon[][]{
//        {new Hexagon(noEddie, toCenter, noEddie, noEddie, toCenter, noEddie), new Hexagon(noEddie, noEddie, fromCenter, noEddie, noEddie, fromCenter)},
//        {new Hexagon(noEddie, toCenter, noEddie, noEddie, toCenter, toCenter), new Hexagon(fromCenter, noEddie, fromCenter, fromCenter, noEddie, noEddie)},
//        {new Hexagon(toCenter, noEddie, noEddie, toCenter, noEddie, toCenter), new Hexagon(noEddie, fromCenter, fromCenter, noEddie, fromCenter, noEddie)},
//        {new Hexagon(noEddie, toCenter, noEddie, toCenter, noEddie, toCenter), new Hexagon(noEddie, fromCenter, noEddie, fromCenter, noEddie, fromCenter)},
//        {new Hexagon(toCenter, toCenter, noEddie, toCenter, toCenter, noEddie), new Hexagon(noEddie, fromCenter, fromCenter, noEddie, fromCenter, fromCenter)}
//    };

//    public final CircularlyLinkedList<Hexagon.eddieDir>[] b = new CircularlyLinkedList[6];
//    public final int[][] a = new int[][]{
//            {2,1,2,2,1,2},
//            {2,1,2,2,1,1}
//    };

       in checkFixedRules method (after return -1)

//if we allow rotations
//        boolean match = false;
//        int count = 0;
//
//        for (Hexagon.eddieDir eddieDir : hex) {
//            if (eddieDir == Hexagon.eddieDir.TC)
//                count++;
//        }
//        int rule;
//        int rotation;
//
//        if(count == 0)
//            return -3; //nothing to do
//        else if(count == 1)
//            return -2; //move forward
//        else if(count == 2){
//            //check if first rule or any of its rotations hold
//            for(int i = 0;i < 3;i++){
//                if (hex[i] == hex[i + 3] && hex[i] == Hexagon.eddieDir.TC) {
//                    rule = 1;
//                    rotation = i; // i-th rotation
//                    break;
//                }
//            }
//        }else if(count == 3){
//
//        }
//
//
//        int[] hexInts = new int[]{hex[0].ordinal(), hex[1].ordinal(), hex[2].ordinal(), hex[3].ordinal(), hex[4].ordinal(), hex[5].ordinal()};
//
//        for(int i = 0; i < 5; i++) { //for every input
////            if (Arrays.equals(hex, input[i])) {
////                return i;
////            }
//            for(int j = 0;j < 6;j++){ //compare input to hexagon
//                match = a[i][j] == hex[j].ordinal();
//            }
//            if(match)
//                return i;
//        }
//        //check for rotations here
//        //add non-fixed rules here?
//        return -1;

//have boolean flags while checking if hexagon is same as input. if flag is false - ignore it next time
//    private void enforceNonFixedRule(Hexagon h){
//        Hexagon.eddieDir[] hex = h.getHexagonEddies();
//
//        boolean[][] flags = new boolean[5][6]; //gather flags for all rules
//        int[] mismatches= new int[5];
//        int collisionEddieCount;
//
//        for (int r = 0;r < input.length;r++) { //for every rule
//            collisionEddieCount = 0;
//            for (int i = 0; i < 6; i++) { //compare each edge
//                if (hex[i] == input[r][i] || hex[i] == Hexagon.eddieDir.FC && input[r][i] == Hexagon.eddieDir.NA) {  // equal || ignore FC eddies
//                    flags[r][i] = true;
//                    if(hex[i] == Hexagon.eddieDir.TC)
//                        collisionEddieCount++;
//                } else{
//                    mismatches[r]++; //mismatch means that there is an eddie in the hexagon that isn't the same as its corresponding input eddie
//                }
//            }
//            // ?
//            if(collisionEddieCount >= 2 && mismatches[r] == 1){ //1. do the update with the least amount of mismatches, or the first one found 2. maybe it would be beneficial to start checking rules from the end, because they have more active eddies 3. ignore that one and do update
//                //ignored FC eddies should be pushed onto the next hexagon !
//                h.updateHexagonEddies(output[r], flags[r]); //give update an array of edges that should be changed according to the table, the others should move forward
//                return;
//            }
//        }
//
//        int smallest = mismatches[0];
//        for(int i = 1;i < mismatches.length;i++){
//            if(mismatches[i] < smallest)
//                smallest = mismatches[i];
//        }
//        //h.updateHexagonEddies() ?
//        //if there is more than one mismatch...
//
//    }


enforce rules
//        else{ //if no rule was found
//            System.out.println("no rule was found");
//            h.updateHexagonEddies(-1,false,null);

enforce non-fixed rules
//            if(mismatches[r] == 0){
//                System.out.println(1);
//                System.out.println(Arrays.toString(flags[r]));
//                h.updateHexagonEddies(r, false, flags[r]);
//                return;
//            }

public static void enforceRule(Hexagon h){
        int rule = checkFixedRules(h);

        if(rule != -1){ //if a rule is found
            h.updateHexagon(rule, true,null);
        }else{
            enforceNonFixedRule(h);
        }
    }


Were in HexGrid

//        VertexGrid vGrid = VertexGrid.getInstance();
x_length = vGrid.getX_length() - 2;
y_width = vGrid.getY_width() - 2;

/**
     * Updates the copy Hexagon (1st step of step)
     * @param copy
     */
    public void update(HexagonGrid copy) {
//        HexagonGrid copy = new HexagonGrid(this); //vGrid.getX_length(), vGrid.getY_width()

        for(int x = 0; x < x_length; x++) { // int x = x_length - 1; x >=0 ; x--
            for (int y = 0; y < y_width; y++) {
                System.out.println(x+ " " + y);
                WolframRules.enforceRule(this.grid[x][y], copy.grid[x][y]);

                System.out.println("original");
                this.pr();
                System.out.println("copy");
                copy.pr();
            }
        }

        //these should be the same
//        System.out.println(copy.grid[0][0].getEdge_se().getDirection());
//        System.out.println(copy.grid[1][1].getEdge_nw().getDirection());
//      //other tests
//        if(this.grid[1][1].getEdge_nw() == this.grid[0][0].getEdge_se()) //we want 1000
//            System.out.println(1000);
//
//        if(copy.grid[1][1].getEdge_nw() == copy.grid[0][0].getEdge_se()) //we want 1500.
//            System.out.println(1500);
//
//        if(this.grid[1][1] != copy.grid[1][1]) //we want 2000. Hexagons are not equal
//            System.out.println(2000);
//
//        if(this.grid[1][1].getEdge_nw() != copy.grid[1][1].getEdge_nw()) //we want 3000. Edges are not equal
//            System.out.println(3000);
//
//        if(this.vGrid != copy.vGrid) //we want 4000.
//            System.out.println(4000);
        //basically, copy constructor isn't making the edges the same
        //why not make it a blank copy? Yes

//        grid = copy.grid;
    }


/**
     * Copies contents of copy Hexagon to the original Hexagon (2st step of step)
     * @param original
     */
    public void copy(HexagonGrid original){
        //throw exception if clone is bigger than original or isn't suitable

        for(int x = 0; x < x_length; x++) { // int x = x_length - 1; x >=0 ; x--
            for (int y = 0; y < y_width; y++) {
                System.out.println(x+ " " + y);

                original.grid[x][y].setEdgeDirections(grid[x][y].getHexagonEddies(),false);

                grid[x][y].setEdgeDirections(new Hexagon.eddieDir[]{Hexagon.eddieDir.NA, Hexagon.eddieDir.NA, Hexagon.eddieDir.NA, Hexagon.eddieDir.NA, Hexagon.eddieDir.NA, Hexagon.eddieDir.NA},true);
                System.out.println("original");
                original.pr();
                System.out.println("copy");
                this.pr();

            }
        }
    }


    //    public static void initialize(int rows, int cols) {
    //        if (instance == null) {
    //            instance = new VertexGrid(rows, cols);
    //        }
    //    }
    //    public static VertexGrid getInstance() {
    //        if (instance == null) {
    //            throw new IllegalStateException("Grid not initialized! Call initialize() first.");
    //        }
    //        return instance;
    //    }

/**
     *In hexagonGrid
     *
     * @param x
     * @param y
     * @param length one hexagon distance = 2edges
     */
    public void insertDiagonalWall(int x, int y, int length){
        Hexagon left;
        Hexagon right;

        left = getHexagon(x, y);
        left.makeWall(4); //verevi teq pate
        right = getHexagon(x+1, y+1);

        for(int i = y;i < y + length; i++){
            left.makeWall(3);
            right.makeWall(3);

            //should check existence of hexagons
//            if(getHexagon(x,i+1) != null)
            left = getHexagon(x,i+1);
            right = getHexagon(x+1,i+2);
        }
        right.makeWall(1);
//        left = this.getNeighbor(left,3);
//        left.makeWall(4); //nerqevi teq pate
    }

    Hexagon

    //    public void makeWall(){
    //        setNull(3);
    //    }

    //    public void makeWall(boolean[] edges){
    //        for(int i = 0; i < edges.length; i++){
    //            if(edges[i]){
    //                setNull(i);
    //            }
    //        }
    //    }

old Panel

import javax.swing.*;
import java.awt.*;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;

public class HexViewerPanel extends JPanel {
    private static final int HEX_SIZE = 10; //radius
    private static final double WIDTH = Math.sqrt(3) * HEX_SIZE;
    private static final double HEIGHT = 2 * HEX_SIZE;

    private final Hexagon[][] hexGrid;

    public HexViewerPanel(Hexagon[][] hexGrid) {
        this.hexGrid = hexGrid;
        setPreferredSize(new Dimension(2560, 1600));
        setBackground(Color.WHITE);
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;

        for (int row = 0; row < hexGrid[0].length; row++) {
            for (int col = 0; col < hexGrid.length; col++) {

                Hexagon hex = hexGrid[col][row];

                double x = col * WIDTH * 0.5; // was *0.5, below: *0.75
                double y = row * HEIGHT * 0.5  - (col % 2 == 0 ? 0 :  HEIGHT / 4);


                drawHex(g2, x, y);
                drawHexEdges(g2, x, y, hex);
            }
        }
    }

    private void drawHex(Graphics2D g2, double x, double y) {
        Path2D hex = new Path2D.Double();

        x += WIDTH / 2;
        y += 3 * HEIGHT / 4 ;

        for (int i = 0; i < 6; i++) {
            double angle = Math.toRadians(60 * i - 30);

            double dx = HEX_SIZE * Math.cos(angle);
            double dy = HEX_SIZE * Math.sin(angle);

            if (i == 0)
                hex.moveTo(x + dx, y + dy);
            else
                hex.lineTo(x + dx, y + dy);
        }
        hex.closePath();
        g2.setColor(Color.LIGHT_GRAY);
        g2.draw(hex);
    }

    private void drawHexEdges(Graphics2D g2, double cx, double cy, Hexagon hex) {
        Edge[] edges = hex.getEdges();

        cx += WIDTH / 2;
        cy += 3 * HEIGHT / 4 ;

        for (int i = 0; i < edges.length; i++) {

            if (edges[i] == null || hex.getEddie(i) == Hexagon.eddieDir.NA)
                continue;

//            cx += WIDTH/2;
//            cy += HEIGHT/4;

            drawArrow(g2, cx, cy, i, hex.getEddie(i));
        }
    }

    private void drawArrow(Graphics2D g2, double cx, double cy, int edgeIndex, Hexagon.eddieDir direction) {

        double angle = Math.toRadians(270 - 60 * edgeIndex);
        double dx = HEX_SIZE * Math.cos(angle);
        double dy = HEX_SIZE * Math.sin(angle);

        double x1, y1, x2, y2;

        if (direction == Hexagon.eddieDir.FC) {
            x1 = cx;
            y1 = cy;
            x2 = cx + dx;
            y2 = cy + dy;
        } else {
            x1 = cx + dx;
            y1 = cy + dy;
            x2 = cx;
            y2 = cy;
        }

        g2.setColor(Color.RED); //direction == Hexagon.eddieDir.FC ? Color.BLUE : Color.RED
        g2.setStroke(new BasicStroke(1));
        g2.draw(new Line2D.Double(x1, y1, x2, y2));
        drawArrowHead(g2, x1, y1, x2, y2);
    }

    private void drawArrowHead(Graphics2D g2, double x1, double y1, double x2, double y2) {
        double phi = Math.toRadians(25);
        int barb = 3;

        double dx = x2 - x1;
        double dy = y2 - y1;
        double theta = Math.atan2(dy, dx);

        double x, y;
        for (int j = 0; j < 2; j++) {
            double rho = theta + (j == 0 ? phi : -phi);
            x = x2 - barb * Math.cos(rho);
            y = y2 - barb * Math.sin(rho);
            g2.draw(new Line2D.Double(x2, y2, x, y));
        }
    }
}


/**
     * Reflects in 2 directions (does not conserve mass)
     * @param hex
     * @param original
     */
    public void reflect3(eddieDir[] hex, Hexagon original){

        //vertical eddies
        if(hex[0] == eddieDir.TC){
            setDirection(3, eddieDir.FC);
            original.setDirection(0, eddieDir.NA);
        }else if(hex[3] == eddieDir.TC){
            setDirection(0, eddieDir.FC);
            original.setDirection(3, eddieDir.NA);
        }

        if(hex[5] == null){ //on left side

            if(hex[2] == eddieDir.TC){ //from below
                setDirection(1, eddieDir.FC);

                Random random = new Random();
                int rand = random.nextInt(0,2);
                if(rand == 0) { //case 1
                    setDirection(0, eddieDir.FC);
                }else{ //case 2
                    setDirection(3, eddieDir.FC);
                }

                original.setDirection(2, eddieDir.NA);
            }
            if(hex[1] == eddieDir.TC){ //from above
                setDirection(2, eddieDir.FC);

                Random random = new Random();
                int rand = random.nextInt(0,2);
                if(rand == 0) { //case 1
                    setDirection(0, eddieDir.FC);
                }else{ //case 2
                    setDirection(3, eddieDir.FC);
                }

                original.setDirection(1, eddieDir.NA);
            }

        }else if(hex[1] == null || hex[2] == null){ //right side
            if(hex[4] == eddieDir.TC){ //from below
                setDirection(5, eddieDir.FC);

                Random random = new Random();
                int rand = random.nextInt(0,2);
                if(rand == 0) { //case 7
                    setDirection(0, eddieDir.FC);
                }else{ //case 8
                    setDirection(3, eddieDir.FC);
                }

                original.setDirection(4, eddieDir.NA);
            }
            if(hex[5] == eddieDir.TC){ //from above
                setDirection(4, eddieDir.FC);

                Random random = new Random();
                int rand = random.nextInt(0,2);
                if(rand == 0) { //case 6
                    setDirection(0, eddieDir.FC);
                }else{ //case 5
                    setDirection(3, eddieDir.FC);
                }

                original.setDirection(5, eddieDir.NA);
            }
        }
    }


/**
     * reflects in other angle direction. Null is 0 and 3 directions (didn't work out)
     * @param hex
     * @param original
     */
    public void reflect1(eddieDir[] hex, Hexagon original){
        //for now assume vertical wall
        if (hex[0] == null || hex[3] == null ) {
            if(hex[1] == eddieDir.TC) {
                setDirection(2, eddieDir.FC);
                original.setDirection(1, eddieDir.NA);
            }
            if(hex[2] == eddieDir.TC){
                setDirection(1, eddieDir.FC);
                original.setDirection(2, eddieDir.NA);
            }
            if(hex[5] == eddieDir.TC){
                setDirection(4, eddieDir.FC);
                original.setDirection(5, eddieDir.NA);
            }
            if(hex[4] == eddieDir.TC){
                setDirection(5, eddieDir.FC);
                original.setDirection(4, eddieDir.NA);
            }
        }
    }

//Old class
import java.util.Arrays;

public class WolframRules {
    //Edge n, Edge nw, Edge sw, Edge s, Edge se, Edge ne

    public static final Hexagon.eddieDir[][] input = new Hexagon.eddieDir[][]{ //5x6
            {Hexagon.eddieDir.NA,Hexagon.eddieDir.TC,Hexagon.eddieDir.NA,Hexagon.eddieDir.NA,Hexagon.eddieDir.TC,Hexagon.eddieDir.NA},//2
            {Hexagon.eddieDir.NA,Hexagon.eddieDir.TC,Hexagon.eddieDir.NA,Hexagon.eddieDir.NA,Hexagon.eddieDir.TC,Hexagon.eddieDir.TC},//3
            {Hexagon.eddieDir.TC,Hexagon.eddieDir.NA,Hexagon.eddieDir.NA,Hexagon.eddieDir.TC,Hexagon.eddieDir.NA,Hexagon.eddieDir.TC},//3
            {Hexagon.eddieDir.NA,Hexagon.eddieDir.TC,Hexagon.eddieDir.NA,Hexagon.eddieDir.TC,Hexagon.eddieDir.NA,Hexagon.eddieDir.TC},//3
            {Hexagon.eddieDir.TC,Hexagon.eddieDir.TC,Hexagon.eddieDir.NA,Hexagon.eddieDir.TC,Hexagon.eddieDir.TC,Hexagon.eddieDir.NA}//4
    };

    public static final Hexagon.eddieDir[][] output = new Hexagon.eddieDir[][]{ //5x6
            {Hexagon.eddieDir.NA,Hexagon.eddieDir.NA,Hexagon.eddieDir.FC,Hexagon.eddieDir.NA,Hexagon.eddieDir.NA,Hexagon.eddieDir.FC},
            {Hexagon.eddieDir.FC,Hexagon.eddieDir.NA,Hexagon.eddieDir.FC,Hexagon.eddieDir.FC,Hexagon.eddieDir.NA,Hexagon.eddieDir.NA},
            {Hexagon.eddieDir.NA,Hexagon.eddieDir.FC,Hexagon.eddieDir.FC,Hexagon.eddieDir.NA,Hexagon.eddieDir.FC,Hexagon.eddieDir.NA},
            {Hexagon.eddieDir.NA,Hexagon.eddieDir.FC,Hexagon.eddieDir.NA,Hexagon.eddieDir.FC,Hexagon.eddieDir.NA,Hexagon.eddieDir.FC},
            {Hexagon.eddieDir.NA,Hexagon.eddieDir.FC,Hexagon.eddieDir.FC,Hexagon.eddieDir.NA,Hexagon.eddieDir.FC,Hexagon.eddieDir.FC}
    };

    /**
     * Checks if there is a corresponding rule for the given hexagon. Rotations not considered
     * @param h hexagon
     * @return the rule to be enforced
     */
    private int checkFixedRules(Hexagon h){
        Hexagon.eddieDir[] hex = h.getHexagonEddies();

        for(int i = 0; i < 5; i++) { //for every rule input
            if (Arrays.equals(hex, input[i])) {
                return i;
            }
        }

        return -1; //move eddies forward
    }

    /**
     * Tries to find a rule by ignoring mismatched eddies. Checks rule conditions on h, applies it on copy.
     * @param h original Hexagon
     * @param copy copy Hexagon
     */
    //have boolean flags while checking if hexagon is same as input. if flag is false - ignore it next time
    private void enforceNonFixedRule(Hexagon h, Hexagon copy){
        Hexagon.eddieDir[] hex = h.getHexagonEddies();

        boolean[][] flags = new boolean[5][6]; //gather flags for all rules
        int[] mismatches= new int[5];
        int collisionEddieCount; //number of eddies in a hexagon
        collisionEddieCount = 0;

        for (int r = 0; r < input.length;r++) { //for every rule
//            System.out.println("rule " + r);

            for (int i = 0; i < 6; i++) { //compare each edge
                if(hex[i] == null) {
                    copy.reflect1(hex, h);
//                    copy.reflect2(hex, h);
                    return;
                }

                if(hex[i] == input[r][i]) {  // equal || (hex[i] == Hexagon.eddieDir.FC && input[r][i] == Hexagon.eddieDir.NA)
                    flags[r][i] = true; //if exactly the same as the rule
                }
                else{
                    if( (hex[i] == Hexagon.eddieDir.FC || hex[i] == Hexagon.eddieDir.TC) && input[r][i] == Hexagon.eddieDir.NA)
                        mismatches[r]++; //this type of mismatch doesn't interfere with the rule being applied
                    else if( (hex[i] == Hexagon.eddieDir.FC || hex[i] == Hexagon.eddieDir.NA) && input[r][i] == Hexagon.eddieDir.TC){
                        mismatches[r] += 20; //this type of mismatch means the rule cannot not be done
                    }
                    else {
                        System.out.println("this should not be reached");
                        mismatches[r] += 2; //if error check this
                    }
                }

                if(r == 0 && hex[i] == Hexagon.eddieDir.TC) {
//                    System.out.println("i am "+ i);
                    collisionEddieCount++;
//                    System.out.println(collisionEddieCount);
                }
            }
//            System.out.println("mismatches are " + mismatches[r]);
//            System.out.println("collision count is " + collisionEddieCount);

            if (collisionEddieCount == 0){
//                System.out.println("no updates needed");
                return;
            }
            else if(collisionEddieCount == 1 || mismatches[r] >= 20){ //there is 1 TC eddie, so it should be pushed forward
//                System.out.println(3);
                copy.updateHexagon(-2, false, null, h); //push forward the TC eddie
                return;
            }
            //if the rule being checked has 1 mismatch, then this is the best rule.
            else if(collisionEddieCount >= 2 && mismatches[r] == 1){ //1. do the update with the least amount of mismatches, or the first one found 2. maybe it would be beneficial to start checking rules from the end, because they have more active eddies 3. ignore that one and do update
//                System.out.println(2 + "rule is" + r);
//                System.out.println(Arrays.toString(flags[r]));
                copy.updateHexagon(r, false, flags[r], h); //give update an array of edges that should be changed according to the table, the others should move forward
                return;
            }
//            else if(mismatches[r] >= 20){
//                //push forward
//                System.out.println("f");
//                copy.updateHexagon(-2,false, null, h);
//            }
        }

        //could be random
        int smallest = 0; // find rule with smallest mismatches
        for(int i = 1; i < mismatches.length; i++){
            if(mismatches[i] <= mismatches[smallest]) //could be < or random
                smallest = i;
        }


//        System.out.println();
//        System.out.println("smallest mismatches are for rule " + smallest);
//        System.out.println(Arrays.toString(flags[smallest]));
        copy.updateHexagon(smallest,false, flags[smallest], h);
    }

    /**
     * Enforces rule on the given Hexagon if there is one, otherwise pushes eddies forward inside the Hexagon
     * @param original
     * @param copy
     */
    public void enforceRule(Hexagon original, Hexagon copy){
        if(copy == null) {
            System.out.println("Clone is null");
            System.exit(0);
        }

        int rule = checkFixedRules(original);

        if(rule != -1){ //if a rule is found
            copy.updateHexagon(rule, true,null, original);
        }else{
//            copy.updateHexagon(-2, false, null, original); //push forward the TC eddie
            enforceNonFixedRule(original, copy);
        }
    }
}
//old class end

//in hexagonGrid
//    public Hexagon getNeighbor(Hexagon hex, int direction){
//        int[] coo = hex.getCenter().getCoordinate();
//
//        switch(direction) {
//            case 0: if(getHexagon(coo[0],coo[1]-1) != null)
//                        return getHexagon(coo[0],coo[1]-1);
//            case 1: if(getHexagon(coo[0]-1,coo[1]) != null)
//                        return getHexagon(coo[0]-1,coo[1]); //left
//
//            case 2: return getHexagon(coo[0]-1,coo[1]+1);
//            case 3: return getHexagon(coo[0],coo[1]+1);
//            case 4: return getHexagon(coo[0]+1,coo[1]+1);
//            case 5: return getHexagon(coo[0]+1,coo[1]); //right
//            default:
//                return null;
//        }
//    }

public Vertex(Vertex original){
        if(original == null){
            System.out.println("ERROR");
            System.exit(0);
        }

        coordinate = new int[2];
        System.arraycopy(original.coordinate, 0,this.coordinate,0,coordinate.length);
//        this.coordinate[0] = original.coordinate[0];
//        this.coordinate[1] = original.coordinate[1];
    }

    public Hexagon(Hexagon original){
            if(original == null){
                System.out.println("ERROR");
                System.exit(0);
            }
            center = new Vertex(original.center);
            edge_n = new Edge(original.edge_n);
            edge_nw = new Edge(original.edge_nw);
            edge_sw = new Edge(original.edge_sw);
            edge_s = new Edge(original.edge_s);
            edge_se = new Edge(original.edge_se);
            edge_ne = new Edge(original.edge_ne);
    //        this.edgeDirections = new eddieDir[6];
    //        System.arraycopy(original.edgeDirections, 0, this.edgeDirections, 0, edgeDirections.length);
        }

public Edge(Edge original){
        if(original == null){
            System.out.println("ERROR");
            System.exit(0);
        }

        this.start = new Vertex(original.start);
        this.end = new Vertex(original.end);
        this.direction = original.direction;
    }

public Edge(eddie direction){
        this.direction = direction;
        start = new Vertex(0,0);
        end = new Vertex(0,0);
    }


Tests:

                                                                VertexGrid
public static void main(String[] args) {
        VertexGrid a = new VertexGrid(5,5);
        for(int i = 0; i < a.y_width;i++){
            for(int j = 0;j < a.x_length;j++){
                System.out.print(a.getVertex(j,i) + " ");
            }
            System.out.println();
        }

        Vertex t = a.getVertex(1,1);
        Vertex t1 = a.getVertex(2,1);
        Vertex t2 = a.getVertex(0,2);

        Edge b = a.getEdge(t1,t);
        System.out.println(b);

        b.setDirection(Edge.eddie.ES);

        Edge c = a.getEdge(t1,t2);
        c.setDirection(Edge.eddie.SE);

        System.out.println(b);
        System.out.println(b.getDirection());
        System.out.println(c);
        System.out.println(c.getDirection());
    }

                                                                HexagonGrid
public static void main(String[] args) {
//        VertexGrid.initialize(4,4);
        HexagonGrid test = new HexagonGrid(4, 4);
//        HexagonGrid clone = new HexagonGrid(4, 4);

        test.pr();
//        test.setUpGrid();
        Hexagon a = test.getHexagon(0,0);
//        Hexagon b = clone.getHexagon(0,0);

//        System.out.println(test.getHexagon(0,0).getEdge_nw().getDirection());
//        System.out.println(test.getHexagon(1,0).getEdge_nw().getDirection());

        if(test.getHexagon(0,0).getEdge_s() == test.getHexagon(0,1).getEdge_n())
            System.out.println(1000);

//        test.getHexagon(0,0).setDirection_s(Hexagon.eddieDir.TC);
        test.getHexagon(0,1).makeWall(0);

        System.out.println("0,0 s edge: "+ test.getHexagon(0,0).getEdge_s());
        System.out.println("0,0 s eddie: "+ test.getHexagon(0,0).getEddie(3));

        System.out.println("0,1 n edge: " + test.getHexagon(0,1).getEdge_n());
        System.out.println("0,1 n eddie: " + test.getHexagon(0,1).getEddie(0));

        test.getHexagon(0,0).setDirection_ne(Hexagon.eddieDir.TC);

//        test.getHexagon(1,0).makeWall(5);
//
//
//        System.out.println("0,0 s edge: "+ test.getHexagon(0,0).getEdge_ne());
//        System.out.println("0,0 s eddie: "+ test.getHexagon(0,0).getEddie(5));
//
//        System.out.println("1,0 n edge: " + test.getHexagon(1,0).getEdge_sw());
//        System.out.println("1,0 n eddie: " + test.getHexagon(1,0).getEddie(2));

        if(test.getHexagon(0,0).getEdge_s() == test.getHexagon(0,1).getEdge_n())
            System.out.println(1500);



//        Grid update tests
//        System.out.println("1st phase");
//        test.update(clone);
//        original
//        NA NA NA NA NA NA    NA NA NA NA FC NA
//        NA NA NA NA FC NA    NA NA NA NA NA NA
//
//        copy
//        NA NA NA NA FC NA    NA NA NA NA FC NA
//        NA NA NA NA FC NA    NA TC NA NA FC NA

//        System.out.println("2nd phase");
//        clone.copy(test);
//        original
//        NA NA NA NA FC NA    NA NA NA NA FC NA
//        NA NA NA NA FC NA    NA TC NA NA FC NA
//
//        copy
//        NA NA NA NA NA NA    NA NA NA NA NA NA
//        NA NA NA NA NA NA    NA NA NA NA NA NA


//        //initial tests
//        System.out.println(a);
//        System.out.println(a.getEdge_n().getDirection()); //should be NA
//        a.setDirection_n(Hexagon.eddieDir.FC);
//        System.out.println(a.getEdge_n().getDirection()); //Should be SE
//        System.out.println(a); //should be FC in 1st direction

//        //rule 0
//        a.setDirection_nw(Hexagon.eddieDir.TC);
//        a.setDirection_se(Hexagon.eddieDir.TC);
//        System.out.println(a);
//        System.out.println(a.getEdge_ne().getDirection()); //Should be NA
//        test.update(clone);
//        clone.copy(test);
        //NA NA FC NA NA FC    NA NA TC NA NA NA
        //NA NA NA NA NA NA    NA NA NA NA NA NA

//        System.out.println(b.getEdge_sw().getDirection()); //Should be ES
//        System.out.println(b.getEdge_ne().getDirection()); //Should be ES

//        //rule 1
//        a.setDirection_nw(Hexagon.eddieDir.TC);
//        a.setDirection_ne(Hexagon.eddieDir.TC);
//        a.setDirection_se(Hexagon.eddieDir.TC);
//        a.setDirection_sw(Hexagon.eddieDir.TC); //with extra TC eddie
//        System.out.println(a);
//        test.update(clone);
//        clone.copy(test);
        //FC NA FC FC NA FC    NA NA TC NA NA NA
        //TC NA NA NA NA NA    NA NA NA NA NA NA

//        //rule 2
//        a.setDirection_se(Hexagon.eddieDir.FC); //with extra FC
//        a.setDirection_sw(Hexagon.eddieDir.TC);//and extra TC
//        a.setDirection_n(Hexagon.eddieDir.TC);
//        a.setDirection_ne(Hexagon.eddieDir.TC);
//        a.setDirection_s(Hexagon.eddieDir.TC);
//        System.out.println(a);
//        test.update(clone);
//        clone.copy(test);
//        NA FC FC NA NA FC    NA NA TC NA NA NA
//        NA NA NA NA NA NA    NA NA NA NA FC NA

//        //rule 3
//        a.setDirection_nw(Hexagon.eddieDir.TC);
//        a.setDirection_sw(Hexagon.eddieDir.FC); //with extra FC eddie
//        a.setDirection_ne(Hexagon.eddieDir.TC);
//        a.setDirection_s(Hexagon.eddieDir.TC);
//        System.out.println(a);
//        test.update(clone);
//        clone.copy(test);
        //NA FC FC FC NA FC    NA NA TC NA NA NA
        //TC NA NA NA NA NA    NA NA NA NA NA NA

//        //rule 4
//        a.setDirection_n(Hexagon.eddieDir.TC);
//        a.setDirection_nw(Hexagon.eddieDir.TC);
//        a.setDirection_s(Hexagon.eddieDir.TC);
//        a.setDirection_se(Hexagon.eddieDir.TC);
//        a.setDirection_sw(Hexagon.eddieDir.FC); //with extra FC eddie
//        System.out.println(a);
//        test.update(clone);
//        clone.copy(test);
        //NA FC FC NA FC FC    NA NA TC NA NA NA
        //NA NA NA NA NA NA    NA TC NA NA NA NA

//        //no rule case
//        a.setDirection_n(Hexagon.eddieDir.TC);
//        a.setDirection_ne(Hexagon.eddieDir.FC);
//        a.setDirection_sw(Hexagon.eddieDir.FC);
//        System.out.println(a);
//        test.update(clone);
//        clone.copy(test);
        //NA NA FC FC NA NA    NA NA NA NA NA FC
        //TC NA NA NA NA NA    NA NA NA NA NA NA

    }
                                                        Hexagon
public static void main(String[] args) {
        eddieDir[] test = new eddieDir[2];
        test[1] = eddieDir.FC;
        System.out.println(test[0]);
    }

                                                            Main
//    public static void main(String[] args) {
//        VertexGrid.initialize(5, 5);
//        VertexGrid vgr = VertexGrid.getInstance();
//
//        HexagonGrid hgr = new HexagonGrid();
//
//        for(int j=0; j<vgr.getY_width();j++){
//            for(int i=0;i< vgr.getX_length();i++){
//                //checking vertices
////                System.out.print(vgr.getVertex(i,j));
//
//            }
////            System.out.println(" ");
//        }
//
//        //checking hexagon centers
//        for(int j = 0; j < hgr.getY_width();j++) {
//            for (int i = 0; i < hgr.getX_length(); i++) {
////                System.out.print(hgr.getHexagon(i,j));
//                //checking neighbors
//                if(i==2 && j==1){
//                    Hexagon test = hgr.getHexagon(i,j);
//
//                    System.out.println(test.getEdge_n());
//                    System.out.println(test.getEdge_nw());
//                    System.out.println(test.getEdge_sw());
//                    System.out.println(test.getEdge_s());
//                    System.out.println(test.getEdge_se());
//                    System.out.println(test.getEdge_ne());
//
//                }
//            }
//            System.out.println(" ");
//        }
//
//
//    }